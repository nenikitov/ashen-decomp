use crate::utils::nom::Result;
use crate::{error::ParseError, utils::nom::FnParser};
use extension::*;

mod pack_info;

pub mod color_map;
pub mod gamma_table;
pub mod model;
pub mod pack_file;
pub mod skybox;
pub mod sound;
pub mod string_table;

/// Definition for all available extensions that the engine can parse.
pub mod extension {
    #[sealed::sealed]
    pub trait Extension: AsRef<str> + for<'str> TryFrom<&'str str> {}

    #[derive(Debug, thiserror::Error)]
    #[error("The provided extension is invalid '{}'", self.0)]
    pub struct ExtensionMismatchError(String);

    macro_rules! impl_extension {
        ($(#[$docs:meta])+ $name:ident => $ext:literal) => {
            $(#[$docs])+
            pub struct $name;

            impl AsRef<str> for $name {
                fn as_ref(&self) -> &str {
                    $ext
                }
            }

            impl TryFrom<&str> for $name {
                type Error = ExtensionMismatchError;

                fn try_from(value: &str) -> Result<Self, Self::Error> {
                    if value == $ext {
                        Ok(Self)
                    } else {
                        Err(ExtensionMismatchError(value.to_owned()))
                    }
                }
            }

            #[sealed::sealed]
            impl Extension for $name {}
        };
    }

    impl_extension!(
        /// Wildcard
        Any => "*"
    );

    impl_extension!(
        /// Extension that implies that the asset comes from ashen's files (packfile).
        Pack => "pack"
    );
}

pub trait AssetParser<Ext>
where
    Self: Sized,
{
    /// The kind of asset generated by this parser.
    ///
    /// _Most_ of the time this would be equal to `Self`. See [`Self::Output`]
    /// for more details.
    type Item = Self;

    /// The final value that would be returned by [`parser`].
    ///
    /// DOCS(Unavailable):
    ///
    /// A hypothetical `TextureCollection` would return `Self` as its output,
    /// however its item "kind" would be `Texture`, because that is the overall
    /// kind of values that it would hold.
    ///
    /// [`parser`]: Self::parser
    type Output = Self::Item;

    /// Extra information passed down to the parser.
    type Context<'ctx> = ();

    /// Generates a new parser with the provided context.
    fn parser(ctx: Self::Context<'_>) -> impl FnParser<Self::Output>;
}

// For the moment we only have implementaions of `AssetParser` where `Ext = Dat`
// that means that we can trivially generate a `AssetParser<Any>` impl without
// too much code boilerplate.
//
// However, this is gonna break coherence once we start adding `Custom` exts.
// Hopefully `negative_impls` will become stable before 2030 :).
impl<T> AssetParser<Any> for T
where
    T: AssetParser<Pack, Output = T, Context<'static> = ()>,
{
    type Context<'ctx> = &'ctx str;

    fn parser(ctx: Self::Context<'_>) -> impl FnParser<Self::Output> {
        move |input| match ctx {
            "pack" => <Self as AssetParser<Pack>>::parser(())(input),
            _ => Err(ParseError::unsupported_extension(input, ctx).into()),
        }
    }
}

// TODO(nenikitov): Remove these, use AssetParser.

pub(crate) trait AssetChunk
where
    Self: Sized,
{
    fn parse(input: &[u8]) -> Result<Self>;
}

pub(crate) trait AssetChunkWithContext
where
    Self: Sized,
{
    type Context<'a>;

    fn parse(context: Self::Context<'_>) -> impl Fn(&[u8]) -> Result<Self>;
}
